/**
 * ğŸ§Ÿ Code Corpses Zombie Detector
 * æ£€æµ‹è¯ˆå°¸ï¼šæ­»æ‰çš„ä»£ç è¢«æ–°é¡¹ç›®å¤ç”¨äº†
 */

import { Octokit } from '@octokit/rest'
import * as fs from 'fs'

interface ZombieCase {
  corpseRepo: string
  corpsePath: string
  zombieRepo: string
  zombiePath: string
  similarity: number
 å¤æ´»æ–¹å¼: string
}

class ZombieDetector {
  private octokit: Octokit
  private owner: string

  constructor(token: string, owner: string) {
    this.octokit = new Octokit({ auth: token })
    this.owner = owner
  }

  /**
   * ğŸ” æ£€æµ‹æ–°ä»£ç æ˜¯å¦"è¯ˆå°¸"
   */
  async detectZombies(newRepo: string, corpsesReport: string): Promise<ZombieCase[]> {
    const zombies: ZombieCase[] = []
    
    // æå–å¢“åœ°é‡Œå·²æœ‰çš„ä»£ç ç‰¹å¾
    const corpsePatterns = this.parseCorpses(corpsesReport)
    
    // æ‰«ææ–°ä»“åº“
    for (const pattern of corpsePatterns) {
      const match = await this.findSimilarCode(newRepo, pattern)
      if (match) {
        zombies.push({
          corpseRepo: pattern.repo,
          corpsePath: pattern.path,
          zombieRepo: newRepo,
          zombiePath: match.path,
          similarity: match.similarity,
         å¤æ´»æ–¹å¼: this.classifyResurrection(match)
        })
      }
    }

    return zombies
  }

  /**
   * ğŸ“– è§£æå¢“ç¢‘æŠ¥å‘Šï¼Œæå–ä»£ç ç‰¹å¾
   */
  private parseCorpses(report: string): { repo: string, path: string, keywords: string[] }[] {
    const corpses: { repo: string, path: string, keywords: string[] }[] = []
    const lines = report.split('\n')
    
    let currentRepo = ''
    for (const line of lines) {
      if (line.startsWith('## ğŸ“‚')) {
        currentRepo = line.replace('## ğŸ“‚ ', '')
      }
      if (line.includes('.ts') || line.includes('.js') || line.includes('.py')) {
        const path = line.split('/').pop()?.trim() || ''
        corpses.push({
          repo: currentRepo,
          path,
          keywords: path.split(/[-_]/).filter(w => w.length > 3)
        })
      }
    }
    
    return corpses
  }

  /**
   * ğŸ” åœ¨æ–°ä»“åº“æ‰¾ç›¸ä¼¼ä»£ç 
   */
  private async findSimilarCode(repo: string, pattern: { keywords: string[] }): Promise<{ path: string, similarity: number } | null> {
    // ç®€åŒ–ç‰ˆï¼šæ£€æŸ¥æ–‡ä»¶åæ˜¯å¦åŒ…å«å¢“ç¢‘ä»£ç çš„å…³é”®è¯
    // å®é™…å¯ä»¥ç”¨æ›´å¤æ‚çš„ç›¸ä¼¼åº¦æ£€æµ‹
    return null
  }

  /**
   * ğŸ¯ åˆ†ç±»è¯ˆå°¸æ–¹å¼
   */
  private classifyResurrection(match: { similarity: number }): string {
    const methods = [
      'ğŸ”„ é‡æ„å¤æ´» - æ”¹äº†ä¸ªåå­—ç»§ç»­ç”¨',
      'ğŸ“¦ æ¨¡å—åŒ–å¤ç”¨ - è¢«æ‹†æˆç‹¬ç«‹åŒ…äº†',
      'ğŸ§  AI è€ƒå¤ - è¢«å¤§æ¨¡å‹æå‡ºæ¥äº†',
      'ğŸ”§ ä¿®ä¿®è¡¥è¡¥ - ç¼ç¼è¡¥è¡¥åˆä¸‰å¹´',
      'ğŸ‘» å€Ÿå°¸è¿˜é­‚ - æ•´ä¸ªé€»è¾‘æ¬è¿‡å»äº†'
    ]
    return methods[Math.floor(Math.random() * methods.length)]
  }

  /**
   * ğŸ‰ ç”Ÿæˆè¯ˆå°¸æŠ¥å‘Š
   */
  generateZombieReport(zombies: ZombieCase[]): string {
    if (zombies.length === 0) {
      return `
# ğŸ§Ÿ è¯ˆå°¸æ£€æµ‹æŠ¥å‘Š

**æ—¶é—´**: ${new Date().toISOString()}

æ²¡æœ‰å‘ç°è¯ˆå°¸äº‹ä»¶ ğŸ’€

å¢“åœ°å¾ˆå®‰é™...
      `
    }

    let report = `
# ğŸ§Ÿ è¯ˆå°¸æ£€æµ‹æŠ¥å‘Š

**æ—¶é—´**: ${new Date().toISOString()}
**è¯ˆå°¸æ•°é‡**: ${zombies.length} å…·

---

## ğŸ‰ è¯ˆå°¸åå•

`

    zombies.forEach((z, i) => {
      report += `
### ${i + 1}. ğŸ§Ÿ è¯ˆå°¸æ¡ˆä¾‹

**å¢“åœ°åœ°å€**: ${z.corpseRepo}/${z.corpsePath}
**å¤æ´»åœ°ç‚¹**: ${z.zombieRepo}/${z.zombiePath}
**ç›¸ä¼¼åº¦**: ${z.similarity}%
**å¤æ´»æ–¹å¼**: ${z.å¤æ´»æ–¹å¼}
      `
    })

    report += `
---

> ğŸ’€ ä»£ç ä¸æ˜¯æ­»äº†ï¼Œåªæ˜¯å»åº¦äº†ä¸ªå‡

---
*Generated by Zombie Detector ğŸ§Ÿ*
    `

    return report
  }
}

// CLI
const args = process.argv.slice(2)

console.log(`
ğŸ§Ÿ Code Corpses Zombie Detector

ç”¨æ³•:
  æ£€æµ‹æ–°ä»“åº“æ˜¯å¦æœ‰è¯ˆå°¸:
  npx code-corpses detect <new-repo-name>

ç¤ºä¾‹:
  npx code-corpses detect my-new-project
`)
